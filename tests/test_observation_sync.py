#!/usr/bin/env python3
"""
Observation Synchronization Verification Test
==============================================

Compares observations generated by:
1. JAX training environment (data_loader.py + env_phase2_jax.py)
2. Agent_temp real-time environment (observation_builder.py)

Both should produce IDENTICAL observations for the same input data.

Run from project root:
    python tests/test_observation_sync.py
    
Or with pytest:
    pytest tests/test_observation_sync.py -v
"""

import sys
import numpy as np
from pathlib import Path
from datetime import datetime, timezone

# Add paths
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT / "src" / "jax_migration"))
sys.path.insert(0, str(PROJECT_ROOT / "Agent_temp"))


def create_test_bar_data(num_bars: int = 20, base_price: float = 25000.0) -> list:
    """
    Create synthetic bar data that can be fed to both systems.
    
    Returns list of bar dictionaries in Agent_temp format.
    """
    bars = []
    np.random.seed(42)  # Reproducible
    
    for i in range(num_bars):
        price = base_price + i * 0.5 + np.random.randn() * 2
        
        # Create timestamp during RTH (10:00 AM + i minutes)
        hour = 10 + (i // 60)
        minute = i % 60
        timestamp = f"2025-12-07T{hour:02d}:{minute:02d}:00.000Z"
        
        bar = {
            'close': price,
            'volume': 1000 + i * 10,
            'sma_5': price - 0.5,
            'sma_20': price - 1.0,
            'rsi': 50 + np.random.randn() * 5,
            'macd': 0.5 + np.random.randn() * 0.1,
            'momentum': 0.001 + np.random.randn() * 0.0005,
            'atr': 8.0 + np.random.randn() * 0.5,
            'timestamp': timestamp,
            'open': price - 0.25,
            'high': price + 0.5,
            'low': price - 0.5,
        }
        bars.append(bar)
    
    return bars


def get_agent_temp_observation(bars: list, position: int = 0) -> np.ndarray:
    """
    Generate observation using Agent_temp observation_builder.
    """
    from observation_builder import ObservationBuilder
    
    builder = ObservationBuilder(mode='phase2')
    
    # Add all bars
    for bar in bars:
        builder.add_bar(bar)
    
    # Set position state
    if position != 0:
        builder.position = position
        builder.entry_price = bars[-1]['close'] - 5.0
        builder.entry_bar_index = len(bars) - 5
        builder.stop_loss_price = builder.entry_price - 10.0 if position == 1 else builder.entry_price + 10.0
        builder.take_profit_price = builder.entry_price + 30.0 if position == 1 else builder.entry_price - 30.0
        builder.current_bar_index = len(bars)
    
    return builder.get_observation()


def get_jax_time_features(bars: list) -> np.ndarray:
    """
    Generate time features using JAX data_loader logic.
    
    This implements the SYNCHRONIZED version from data_loader.py.
    """
    time_features = []
    
    for bar in bars:
        timestamp_str = bar['timestamp']
        dt = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
        
        # Match Agent_temp calculation (observation_builder.py lines 163-178)
        hour = dt.hour
        minute = dt.minute
        
        # hour_norm = hour / 24.0
        hour_norm = hour / 24.0
        
        # min_from_open = current_minutes - open_minutes
        open_minutes = 9 * 60 + 30  # 9:30 AM = 570
        current_minutes = hour * 60 + minute
        min_from_open = float(current_minutes - open_minutes)
        
        # min_to_close = close_minutes - current_minutes
        close_minutes = 16 * 60 + 59  # 4:59 PM = 1019
        min_to_close = float(close_minutes - current_minutes)
        
        time_features.append([hour_norm, min_from_open, min_to_close])
    
    return np.array(time_features, dtype=np.float32)


def get_jax_market_features(bars: list) -> np.ndarray:
    """
    Generate market features from bars in JAX format.
    
    Returns (num_bars, 8) array.
    """
    features = []
    for bar in bars:
        features.append([
            bar['close'],
            bar['volume'],
            bar['sma_5'],
            bar['sma_20'],
            bar['rsi'],
            bar['macd'],
            bar['momentum'],
            bar['atr'],
        ])
    return np.array(features, dtype=np.float32)


def build_jax_observation(bars: list, position: int = 0) -> np.ndarray:
    """
    Build observation using JAX environment logic.
    
    This replicates env_phase2_jax.py:get_observation_phase2()
    """
    # Market features (8 per bar)
    market_features = get_jax_market_features(bars)  # (20, 8)
    
    # Time features (3 per bar)
    time_features = get_jax_time_features(bars)  # (20, 3)
    
    # Combine and flatten (same as JAX: concatenate on axis=1, then flatten)
    combined = np.concatenate([market_features, time_features], axis=1)  # (20, 11)
    flat_obs = combined.flatten()  # (220,)
    
    # Current market data
    current_price = bars[-1]['close']
    current_atr = bars[-1]['atr']
    safe_atr = current_atr if current_atr > 0 else current_price * 0.01
    safe_price = current_price if current_price > 0 else 1.0
    
    # Position features (5 dims) - matches env_phase2_jax.py logic
    has_position = position != 0
    
    if has_position:
        entry_price = bars[-1]['close'] - 5.0
        entry_bar = len(bars) - 5
        sl_price = entry_price - 10.0 if position == 1 else entry_price + 10.0
        tp_price = entry_price + 30.0 if position == 1 else entry_price - 30.0
        
        position_features = np.array([
            float(position),
            entry_price / safe_price,
            abs(sl_price - safe_price) / safe_atr,
            abs(tp_price - safe_price) / safe_atr,
            float(len(bars) - entry_bar),  # RAW bars (SYNCHRONIZED - no /390.0)
        ], dtype=np.float32)
    else:
        position_features = np.array([0.0, 1.0, 0.0, 0.0, 0.0], dtype=np.float32)
    
    # Phase 2 features (3 dims)
    trailing_active = 0.0
    unrealized_pnl = 0.0
    be_move_count = 0.0
    
    phase2_features = np.array([
        trailing_active,
        unrealized_pnl / 1000.0 if has_position else 0.0,
        be_move_count / 3.0,
    ], dtype=np.float32)
    
    # Validity features (3 dims) - SYNCHRONIZED: can_enter only checks position
    can_enter = 1.0 if position == 0 else 0.0
    can_manage = 1.0 if has_position else 0.0
    has_pos = 1.0 if has_position else 0.0
    
    validity_features = np.array([can_enter, can_manage, has_pos], dtype=np.float32)
    
    # Combine all: 220 + 5 + 3 + 3 = 231
    obs = np.concatenate([flat_obs, position_features, phase2_features, validity_features])
    
    return obs.astype(np.float32)


def test_time_feature_sync():
    """Test that time features are calculated identically."""
    print("\n" + "="*70)
    print("TEST 1: Time Feature Synchronization")
    print("="*70)
    
    bars = create_test_bar_data(num_bars=20)
    
    # Get Agent_temp time features
    from observation_builder import ObservationBuilder
    builder = ObservationBuilder(mode='phase2')
    
    agent_temp_time = []
    for bar in bars:
        builder.add_bar(bar)
        # Get time features from latest bar
        last_bar = list(builder.bar_window)[-1]
        agent_temp_time.append([
            last_bar['hour_norm'],
            last_bar['min_from_open'],
            last_bar['min_to_close'],
        ])
    agent_temp_time = np.array(agent_temp_time)
    
    # Get JAX time features
    jax_time = get_jax_time_features(bars)
    
    print(f"\nAgent_temp time features shape: {agent_temp_time.shape}")
    print(f"JAX time features shape: {jax_time.shape}")
    
    print("\nSample comparison (first 3 bars):")
    print(f"{'Bar':>4} | {'Feature':>15} | {'Agent_temp':>12} | {'JAX':>12} | {'Match':>6}")
    print("-" * 65)
    
    all_match = True
    for i in range(min(3, len(bars))):
        for j, name in enumerate(['hour_norm', 'min_from_open', 'min_to_close']):
            at_val = agent_temp_time[i, j]
            jax_val = jax_time[i, j]
            match = np.isclose(at_val, jax_val, rtol=1e-5)
            all_match = all_match and match
            print(f"{i:>4} | {name:>15} | {at_val:>12.4f} | {jax_val:>12.4f} | {'✓' if match else '✗':>6}")
    
    if all_match:
        print("\n✅ Time features are SYNCHRONIZED")
    else:
        print("\n❌ Time features MISMATCH detected!")
    
    return all_match


def test_full_observation_sync():
    """Test that full observations match between systems."""
    print("\n" + "="*70)
    print("TEST 2: Full Observation Synchronization (FLAT position)")
    print("="*70)
    
    bars = create_test_bar_data(num_bars=20)
    
    # Get observations from both systems
    agent_temp_obs = get_agent_temp_observation(bars, position=0)
    jax_obs = build_jax_observation(bars, position=0)
    
    print(f"\nAgent_temp observation shape: {agent_temp_obs.shape}")
    print(f"JAX observation shape: {jax_obs.shape}")
    
    # Compare sections
    sections = [
        ("Market features (0-219)", 0, 220),
        ("Position features (220-224)", 220, 225),
        ("Phase2 features (225-227)", 225, 228),
        ("Validity features (228-230)", 228, 231),
    ]
    
    all_match = True
    for name, start, end in sections:
        at_section = agent_temp_obs[start:end]
        jax_section = jax_obs[start:end]
        
        max_diff = np.abs(at_section - jax_section).max()
        # Use 1e-2 tolerance for market features (float32 precision + different sources)
        # Position/Phase2/Validity features should be exact
        tolerance = 1e-2 if start == 0 else 1e-4
        match = max_diff < tolerance
        all_match = all_match and match
        
        status = "✓" if match else "✗"
        print(f"\n{name}:")
        print(f"  Max difference: {max_diff:.6f} {status}")
        
        if not match:
            # Show first mismatch
            diff_idx = np.argmax(np.abs(at_section - jax_section))
            print(f"  First mismatch at index {start + diff_idx}:")
            print(f"    Agent_temp: {at_section[diff_idx]:.6f}")
            print(f"    JAX:        {jax_section[diff_idx]:.6f}")
    
    if all_match:
        print("\n✅ Full observations are SYNCHRONIZED")
    else:
        print("\n❌ Observation MISMATCH detected!")
    
    return all_match


def test_position_observation_sync():
    """Test observations with active position."""
    print("\n" + "="*70)
    print("TEST 3: Observation with LONG Position")
    print("="*70)
    
    bars = create_test_bar_data(num_bars=20)
    
    # Get observations with position
    agent_temp_obs = get_agent_temp_observation(bars, position=1)
    jax_obs = build_jax_observation(bars, position=1)
    
    # Focus on position-related features
    print("\nPosition features comparison:")
    feature_names = [
        "position",
        "entry_price_ratio",
        "sl_distance_atr",
        "tp_distance_atr",
        "time_in_position",
    ]
    
    all_match = True
    for i, name in enumerate(feature_names):
        at_val = agent_temp_obs[220 + i]
        jax_val = jax_obs[220 + i]
        match = np.isclose(at_val, jax_val, rtol=1e-3)
        all_match = all_match and match
        status = "✓" if match else "✗"
        print(f"  {name:20s}: Agent_temp={at_val:10.4f}, JAX={jax_val:10.4f} {status}")
    
    if all_match:
        print("\n✅ Position features are SYNCHRONIZED")
    else:
        print("\n❌ Position features MISMATCH detected!")
    
    return all_match


def main():
    """Run all synchronization tests."""
    print("\n" + "="*70)
    print(" OBSERVATION SYNCHRONIZATION VERIFICATION")
    print(" JAX Training <-> Agent_temp Real-Time")
    print("="*70)
    
    results = []
    
    # Run tests
    results.append(("Time Features", test_time_feature_sync()))
    results.append(("Full Observation (FLAT)", test_full_observation_sync()))
    results.append(("Position Observation", test_position_observation_sync()))
    
    # Summary
    print("\n" + "="*70)
    print(" SUMMARY")
    print("="*70)
    
    all_passed = True
    for name, passed in results:
        status = "✅ PASS" if passed else "❌ FAIL"
        print(f"  {name:30s}: {status}")
        all_passed = all_passed and passed
    
    print("\n" + "="*70)
    if all_passed:
        print(" ✅ ALL TESTS PASSED - Environments are SYNCHRONIZED!")
    else:
        print(" ❌ SOME TESTS FAILED - Check mismatches above")
    print("="*70 + "\n")
    
    return 0 if all_passed else 1


if __name__ == "__main__":
    sys.exit(main())
